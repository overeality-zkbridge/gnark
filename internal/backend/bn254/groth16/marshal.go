// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by gnark DO NOT EDIT

package groth16

import (
	"encoding/binary"
	"fmt"
	curve "github.com/consensys/gnark-crypto/ecc/bn254"
	"github.com/consensys/gnark-crypto/ecc/bn254/fp"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"io"
	"io/ioutil"
	"time"
	"unsafe"
)

// WriteTo writes binary encoding of the Proof elements to writer
// points are stored in compressed form Ar | Krs | Bs
// use WriteRawTo(...) to encode the proof without point compression
func (proof *Proof) WriteTo(w io.Writer) (n int64, err error) {
	return proof.writeTo(w, false)
}

// WriteRawTo writes binary encoding of the Proof elements to writer
// points are stored in uncompressed form Ar | Krs | Bs
// use WriteTo(...) to encode the proof with point compression
func (proof *Proof) WriteRawTo(w io.Writer) (n int64, err error) {
	return proof.writeTo(w, true)
}

func (proof *Proof) writeTo(w io.Writer, raw bool) (int64, error) {
	var enc *curve.Encoder
	if raw {
		enc = curve.NewEncoder(w, curve.RawEncoding())
	} else {
		enc = curve.NewEncoder(w)
	}

	if err := enc.Encode(&proof.Ar); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(&proof.Bs); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(&proof.Krs); err != nil {
		return enc.BytesWritten(), err
	}
	return enc.BytesWritten(), nil
}

// ReadFrom attempts to decode a Proof from reader
// Proof must be encoded through WriteTo (compressed) or WriteRawTo (uncompressed)
func (proof *Proof) ReadFrom(r io.Reader) (n int64, err error) {

	dec := curve.NewDecoder(r)

	if err := dec.Decode(&proof.Ar); err != nil {
		return dec.BytesRead(), err
	}
	if err := dec.Decode(&proof.Bs); err != nil {
		return dec.BytesRead(), err
	}
	if err := dec.Decode(&proof.Krs); err != nil {
		return dec.BytesRead(), err
	}

	return dec.BytesRead(), nil
}

// WriteTo writes binary encoding of the key elements to writer
// points are compressed
// use WriteRawTo(...) to encode the key without point compression
func (vk *VerifyingKey) WriteTo(w io.Writer) (n int64, err error) {
	return vk.writeTo(w, false)
}

// WriteRawTo writes binary encoding of the key elements to writer
// points are not compressed
// use WriteTo(...) to encode the key with point compression
func (vk *VerifyingKey) WriteRawTo(w io.Writer) (n int64, err error) {
	return vk.writeTo(w, true)
}

// writeTo serialization format:
// follows bellman format:
// https://github.com/zkcrypto/bellman/blob/fa9be45588227a8c6ec34957de3f68705f07bd92/src/groth16/mod.rs#L143
// [α]1,[β]1,[β]2,[γ]2,[δ]1,[δ]2,uint32(len(Kvk)),[Kvk]1
func (vk *VerifyingKey) writeTo(w io.Writer, raw bool) (int64, error) {
	var enc *curve.Encoder
	if raw {
		enc = curve.NewEncoder(w, curve.RawEncoding())
	} else {
		enc = curve.NewEncoder(w)
	}

	// [α]1,[β]1,[β]2,[γ]2,[δ]1,[δ]2
	if err := enc.Encode(&vk.G1.Alpha); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(&vk.G1.Beta); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(&vk.G2.Beta); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(&vk.G2.Gamma); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(&vk.G1.Delta); err != nil {
		return enc.BytesWritten(), err
	}
	if err := enc.Encode(&vk.G2.Delta); err != nil {
		return enc.BytesWritten(), err
	}

	// uint32(len(Kvk)),[Kvk]1
	if err := enc.Encode(vk.G1.K); err != nil {
		return enc.BytesWritten(), err
	}
	return enc.BytesWritten(), nil
}

// ReadFrom attempts to decode a VerifyingKey from reader
// VerifyingKey must be encoded through WriteTo (compressed) or WriteRawTo (uncompressed)
// serialization format:
// https://github.com/zkcrypto/bellman/blob/fa9be45588227a8c6ec34957de3f68705f07bd92/src/groth16/mod.rs#L143
// [α]1,[β]1,[β]2,[γ]2,[δ]1,[δ]2,uint32(len(Kvk)),[Kvk]1
func (vk *VerifyingKey) ReadFrom(r io.Reader) (int64, error) {
	return vk.readFrom(r)
}

// UnsafeReadFrom has the same behavior as ReadFrom, except that it will not check that decode points
// are on the curve and in the correct subgroup.
func (vk *VerifyingKey) UnsafeReadFrom(r io.Reader) (int64, error) {
	return vk.readFrom(r, curve.NoSubgroupChecks())
}

func (vk *VerifyingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {
	dec := curve.NewDecoder(r, decOptions...)

	// [α]1,[β]1,[β]2,[γ]2,[δ]1,[δ]2
	if err := dec.Decode(&vk.G1.Alpha); err != nil {
		return dec.BytesRead(), err
	}
	if err := dec.Decode(&vk.G1.Beta); err != nil {
		return dec.BytesRead(), err
	}
	if err := dec.Decode(&vk.G2.Beta); err != nil {
		return dec.BytesRead(), err
	}
	if err := dec.Decode(&vk.G2.Gamma); err != nil {
		return dec.BytesRead(), err
	}
	if err := dec.Decode(&vk.G1.Delta); err != nil {
		return dec.BytesRead(), err
	}
	if err := dec.Decode(&vk.G2.Delta); err != nil {
		return dec.BytesRead(), err
	}

	// uint32(len(Kvk)),[Kvk]1
	if err := dec.Decode(&vk.G1.K); err != nil {
		return dec.BytesRead(), err
	}

	// recompute vk.e (e(α, β)) and  -[δ]2, -[γ]2
	var err error
	vk.e, err = curve.Pair([]curve.G1Affine{vk.G1.Alpha}, []curve.G2Affine{vk.G2.Beta})
	if err != nil {
		return dec.BytesRead(), err
	}
	vk.G2.deltaNeg.Neg(&vk.G2.Delta)
	vk.G2.gammaNeg.Neg(&vk.G2.Gamma)

	return dec.BytesRead(), nil
}

// WriteTo writes binary encoding of the key elements to writer
// points are compressed
// use WriteRawTo(...) to encode the key without point compression
func (pk *ProvingKey) WriteTo(w io.Writer) (n int64, err error) {
	return pk.writeTo(w, false)
}

// WriteRawTo writes binary encoding of the key elements to writer
// points are not compressed
// use WriteTo(...) to encode the key with point compression
func (pk *ProvingKey) WriteRawTo(w io.Writer) (n int64, err error) {
	return pk.writeTo(w, true)
}

func FpElementToBytes(e fp.Element) []byte {
	//b := e.Bytes()
	var b [32]byte
	var data [4]uint64
	data[0] = e[0]
	data[1] = e[1]
	data[2] = e[2]
	data[3] = e[3]

	binary.LittleEndian.PutUint64(b[0:8], data[0])
	binary.LittleEndian.PutUint64(b[8:16], data[1])
	binary.LittleEndian.PutUint64(b[16:24], data[2])
	binary.LittleEndian.PutUint64(b[24:32], data[3])
	return b[:]
}

func G1AffineToBytes(e curve.G1Affine) []byte {
	//no compression
	result := make([]byte, 64)
	copy(result[:32], FpElementToBytes(e.X))
	copy(result[32:], FpElementToBytes(e.Y))
	return result
}

func G2AffineToBytes(e curve.G2Affine) []byte {
	//no compression
	result := make([]byte, 128)
	copy(result[:32], FpElementToBytes(e.X.A0))
	copy(result[32:64], FpElementToBytes(e.X.A1))
	copy(result[64:96], FpElementToBytes(e.Y.A0))
	copy(result[96:], FpElementToBytes(e.Y.A1))
	return result
}

func G1AffineArrayToBytes(e []curve.G1Affine) []byte {
	result := make([]byte, 0)
	result = append(result, int_to_byte(len(e))...)
	for _, v := range e {
		result = append(result, G1AffineToBytes(v)...)
	}
	return result
}
func G2AffineArrayToBytes(e []curve.G2Affine) []byte {
	result := make([]byte, 0)
	result = append(result, int_to_byte(len(e))...)
	for _, v := range e {
		result = append(result, G2AffineToBytes(v)...)
	}
	return result
}

func readG1AffineArray(r io.Reader, directout bool, filename string) []curve.G1Affine {
	fmt.Println("readG1AffineArray")
	t0 := time.Now()
	var result []curve.G1Affine

	if directout {
		t2 := time.Now()
		fileBytes, err := ioutil.ReadFile(filename)
		t3 := time.Now()
		fmt.Println("readG1AffineArray read file", t3.Sub(t2))
		if err != nil {
			fmt.Println("readG1AffineArray error")
			panic(err)
		}

		length := byte_to_int(fileBytes[:8])
		usedBytes := 8
		result = make([]curve.G1Affine, length)
		for i := 0; i < length; i++ {
			g1Bytes := fileBytes[usedBytes : usedBytes+64]
			usedBytes += 64
			result[i] = byte_to_G1Affine(g1Bytes)
		}
	} else {
		lengthByte := make([]byte, 8)
		r.Read(lengthByte)
		length := byte_to_int(lengthByte)
		result = make([]curve.G1Affine, length)
		for i := 0; i < length; i++ {
			g1Bytes := make([]byte, 64)
			r.Read(g1Bytes)
			result[i] = byte_to_G1Affine(g1Bytes)
		}
	}
	fmt.Println("readG1AffineArray time:", time.Since(t0))
	return result
}

func readG2AffineArray(r io.Reader, directout bool, filename string) []curve.G2Affine {
	fmt.Println("readG2AffineArray")
	t0 := time.Now()
	var result []curve.G2Affine

	if directout {
		fileBytes, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Println("readG2AffineArray error")
			panic(err)
		}
		length := byte_to_int(fileBytes[:8])
		usedBytes := 8
		result = make([]curve.G2Affine, length)
		for i := 0; i < length; i++ {
			g2Bytes := fileBytes[usedBytes : usedBytes+128]
			usedBytes += 128
			result[i] = byte_to_G2Affine(g2Bytes)
		}
	} else {
		lengthByte := make([]byte, 8)
		r.Read(lengthByte)
		length := byte_to_int(lengthByte)
		result = make([]curve.G2Affine, length)
		for i := 0; i < length; i++ {
			g2Bytes := make([]byte, 128)
			r.Read(g2Bytes)
			result[i] = byte_to_G2Affine(g2Bytes)
		}
	}
	fmt.Println("readG2AffineArray time:", time.Since(t0))
	return result
}

func int_to_byte(x int) []byte {
	var b [8]byte
	if unsafe.Sizeof(x) == 8 {
		binary.LittleEndian.PutUint64(b[:], uint64(x))
	} else {
		panic("unknown int size")
	}
	return b[:]
}

func uint64_to_byte(x uint64) []byte {
	var b [8]byte
	binary.LittleEndian.PutUint64(b[:], x)
	return b[:]
}

func uint32_to_byte(x uint32) []byte {
	var buf [4]byte
	binary.LittleEndian.PutUint32(buf[:], x)
	return buf[:]
}

func frElement_to_byte(e fr.Element) []byte {
	var b [32]byte
	var data [4]uint64
	data[0] = e[0]
	data[1] = e[1]
	data[2] = e[2]
	data[3] = e[3]
	for i := 0; i < 4; i++ {
		binary.LittleEndian.PutUint64(b[i*8:], data[i])
	}
	return b[:]
}

func frElementArrayToByte(e []fr.Element) []byte {
	result := make([]byte, 0)
	result = append(result, int_to_byte(len(e))...)
	for _, v := range e {
		result = append(result, frElement_to_byte(v)...)
	}
	return result
}

func frElementArrayToByteDim2(e [][]fr.Element) []byte {
	result := make([]byte, 0)
	result = append(result, int_to_byte(len(e))...)
	for _, v := range e {
		result = append(result, frElementArrayToByte(v)...)
	}
	return result
}

func boolArrayToByte(e []bool) []byte {
	result := make([]byte, 0)
	result = append(result, int_to_byte(len(e))...)
	for _, v := range e {
		if v {
			result = append(result, 1)
		} else {
			result = append(result, 0)
		}
	}
	return result
}

func ReadBoolArray(r io.Reader) []bool {
	var result []bool
	lengthByte := make([]byte, 8)
	r.Read(lengthByte)
	length := byte_to_int(lengthByte)
	b := make([]byte, length)
	r.Read(b)
	for i := 0; i < length; i++ {
		if b[i] == 1 {
			result = append(result, true)
		} else {
			result = append(result, false)
		}
	}
	return result
}

func (pk *ProvingKey) writeTo(w io.Writer, raw bool) (int64, error) {
	fmt.Println("Writing Proving Key")
	/*
		n, err := pk.Domain.WriteTo(w)
		if err != nil {
			return n, err
		}

		var enc *curve.Encoder
		if raw {
			enc = curve.NewEncoder(w, curve.RawEncoding())
		} else {
			enc = curve.NewEncoder(w)
		}
		nbWires := uint64(len(pk.InfinityA))

		toEncode := []interface{}{
			&pk.G1.Alpha,
			&pk.G1.Beta,
			&pk.G1.Delta,
			pk.G1.A,
			pk.G1.B,
			pk.G1.Z,
			pk.G1.K,
			&pk.G2.Beta,
			&pk.G2.Delta,
			pk.G2.B,
			nbWires,
			pk.NbInfinityA,
			pk.NbInfinityB,
			pk.InfinityA,
			pk.InfinityB,
		}

		for _, v := range toEncode {
			if err := enc.Encode(v); err != nil {
				return n + enc.BytesWritten(), err
			}
		}

		return n + enc.BytesWritten(), nil
	*/
	//domain
	w.Write(uint64_to_byte(pk.Domain.Cardinality))
	w.Write(frElement_to_byte(pk.Domain.CardinalityInv))
	w.Write(frElement_to_byte(pk.Domain.Generator))
	w.Write(frElement_to_byte(pk.Domain.GeneratorInv))
	w.Write(frElement_to_byte(pk.Domain.FrMultiplicativeGen))
	w.Write(frElement_to_byte(pk.Domain.FrMultiplicativeGenInv))

	w.Write(frElementArrayToByteDim2(pk.Domain.Twiddles))
	w.Write(frElementArrayToByteDim2(pk.Domain.TwiddlesInv))

	w.Write(frElementArrayToByte(pk.Domain.CosetTable))
	w.Write(frElementArrayToByte(pk.Domain.CosetTableReversed))
	w.Write(frElementArrayToByte(pk.Domain.CosetTableInv))
	w.Write(frElementArrayToByte(pk.Domain.CosetTableInvReversed))

	// G1
	w.Write(G1AffineToBytes(pk.G1.Alpha))
	w.Write(G1AffineToBytes(pk.G1.Beta))
	w.Write(G1AffineToBytes(pk.G1.Delta))

	w.Write(G1AffineArrayToBytes(pk.G1.A))
	w.Write(G1AffineArrayToBytes(pk.G1.B))
	w.Write(G1AffineArrayToBytes(pk.G1.Z))
	w.Write(G1AffineArrayToBytes(pk.G1.K))

	//G2
	w.Write(G2AffineToBytes(pk.G2.Beta))
	w.Write(G2AffineToBytes(pk.G2.Delta))
	w.Write(G2AffineArrayToBytes(pk.G2.B))

	//nbWires
	w.Write(uint64_to_byte(uint64(len(pk.InfinityA))))
	//nbInfinityA
	w.Write(uint64_to_byte(pk.NbInfinityA))
	//nbInfinityB
	w.Write(uint64_to_byte(pk.NbInfinityB))
	//infinityA
	w.Write(boolArrayToByte(pk.InfinityA))
	//infinityB
	w.Write(boolArrayToByte(pk.InfinityB))

	return 0, nil
}

// ReadFrom attempts to decode a ProvingKey from reader
// ProvingKey must be encoded through WriteTo (compressed) or WriteRawTo (uncompressed)
// note that we don't check that the points are on the curve or in the correct subgroup at this point
func (pk *ProvingKey) ReadFrom(r io.Reader) (int64, error) {
	return pk.readFrom(r)
}

// UnsafeReadFrom behaves like ReadFrom excepts it doesn't check if the decoded points are on the curve
// or in the correct subgroup
func (pk *ProvingKey) UnsafeReadFrom(r io.Reader) (int64, error) {
	return pk.readFrom(r, curve.NoSubgroupChecks())
}

func byte_to_int(b []byte) int {
	result_uint64 := binary.LittleEndian.Uint64(b[:8])
	result := int(result_uint64)
	return result
}

func byte_to_uint64(b []byte) uint64 {
	result := binary.LittleEndian.Uint64(b[:8])
	return result
}

func byte_to_frElement(b []byte) fr.Element {
	var result fr.Element
	result[0] = binary.LittleEndian.Uint64(b[:8])
	result[1] = binary.LittleEndian.Uint64(b[8:16])
	result[2] = binary.LittleEndian.Uint64(b[16:24])
	result[3] = binary.LittleEndian.Uint64(b[24:32])
	return result
}

func readFrElementArray(r io.Reader, directout bool, filename string) []fr.Element {
	var result []fr.Element
	if directout {
		fileBytes, err := ioutil.ReadFile(filename)
		if err != nil {
			panic(err)
		}
		lengthByte := fileBytes[:8]
		byteUsed := 8
		length := byte_to_int(lengthByte)
		result = make([]fr.Element, length)
		for i := 0; i < length; i++ {
			result[i] = byte_to_frElement(fileBytes[byteUsed : byteUsed+32])
			byteUsed += 32
		}
	} else {
		lengthByte := make([]byte, 8)
		r.Read(lengthByte)
		length := byte_to_int(lengthByte)
		result = make([]fr.Element, length)
		for i := 0; i < length; i++ {
			frByte := make([]byte, 32)
			r.Read(frByte)
			result[i] = byte_to_frElement(frByte)
		}
	}
	return result
}

func readFrElementArrayDim2(r io.Reader, directout bool, filename string) [][]fr.Element {
	fmt.Println("Reading FrElementArrayDim2")
	t0 := time.Now()
	var result [][]fr.Element

	if directout {
		fileBytes, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Println("Error reading file")
			panic(err)
		}
		lengthByte := fileBytes[:8]
		byteUsed := 8
		length := byte_to_int(lengthByte)
		for i := 0; i < length; i++ {
			lengthByte2 := fileBytes[byteUsed : byteUsed+8]
			length2 := byte_to_int(lengthByte2)
			byteUsed += 8
			result2 := make([]fr.Element, length2)
			for j := 0; j < length2; j++ {
				frByte := fileBytes[byteUsed : byteUsed+32]
				result2[j] = byte_to_frElement(frByte)
				byteUsed += 32
			}
			result = append(result, result2)
		}
	} else {
		lengthByte := make([]byte, 8)
		r.Read(lengthByte)
		length := byte_to_int(lengthByte)
		for i := 0; i < length; i++ {
			result = append(result, readFrElementArray(r, false, ""))
		}
	}
	t1 := time.Now()
	fmt.Println("Reading FrElementArrayDim2 took", t1.Sub(t0))
	return result
}

func byte_to_fpElement(b []byte) fp.Element {
	var result fp.Element
	result[0] = binary.LittleEndian.Uint64(b[:8])
	result[1] = binary.LittleEndian.Uint64(b[8:16])
	result[2] = binary.LittleEndian.Uint64(b[16:24])
	result[3] = binary.LittleEndian.Uint64(b[24:32])
	return result
}

func byte_to_G1Affine(b []byte) curve.G1Affine {
	var result curve.G1Affine
	result.X = byte_to_fpElement(b[:32])
	result.Y = byte_to_fpElement(b[32:64])
	return result
}

func byte_to_G2Affine(b []byte) curve.G2Affine {
	var result curve.G2Affine
	result.X.A0 = byte_to_fpElement(b[:32])
	result.X.A1 = byte_to_fpElement(b[32:64])
	result.Y.A0 = byte_to_fpElement(b[64:96])
	result.Y.A1 = byte_to_fpElement(b[96:128])
	return result
}

func (pk *ProvingKey) readFrom(r io.Reader, decOptions ...func(*curve.Decoder)) (int64, error) {
	fmt.Println("Reading proving key")
	/*
		n, err := pk.Domain.ReadFrom(r)
		if err != nil {
			return n, err
		}

		dec := curve.NewDecoder(r, decOptions...)

		var nbWires uint64

		toDecode := []interface{}{
			&pk.G1.Alpha,
			&pk.G1.Beta,
			&pk.G1.Delta,
			&pk.G1.A,
			&pk.G1.B,
			&pk.G1.Z,
			&pk.G1.K,
			&pk.G2.Beta,
			&pk.G2.Delta,
			&pk.G2.B,
			&nbWires,
			&pk.NbInfinityA,
			&pk.NbInfinityB,
		}

		for _, v := range toDecode {
			if err := dec.Decode(v); err != nil {
				return n + dec.BytesRead(), err
			}
		}
		pk.InfinityA = make([]bool, nbWires)
		pk.InfinityB = make([]bool, nbWires)

		if err := dec.Decode(&pk.InfinityA); err != nil {
			return n + dec.BytesRead(), err
		}
		if err := dec.Decode(&pk.InfinityB); err != nil {
			return n + dec.BytesRead(), err
		}

		return n + dec.BytesRead(), nil
	*/
	//domain
	pkDomainCardinalityBytes := make([]byte, 8)
	r.Read(pkDomainCardinalityBytes)
	pk.Domain.Cardinality = byte_to_uint64(pkDomainCardinalityBytes)
	pkDomainCardinalityInvBytes := make([]byte, 32)
	r.Read(pkDomainCardinalityInvBytes)
	pk.Domain.CardinalityInv = byte_to_frElement(pkDomainCardinalityInvBytes)
	pkDomainGeneratorBytes := make([]byte, 32)
	r.Read(pkDomainGeneratorBytes)
	pk.Domain.Generator = byte_to_frElement(pkDomainGeneratorBytes)
	pkDomainGeneratorInvBytes := make([]byte, 32)
	r.Read(pkDomainGeneratorInvBytes)
	pk.Domain.GeneratorInv = byte_to_frElement(pkDomainGeneratorInvBytes)
	pkDomainFrMultiplicativeGenBytes := make([]byte, 32)
	r.Read(pkDomainFrMultiplicativeGenBytes)
	pk.Domain.FrMultiplicativeGen = byte_to_frElement(pkDomainFrMultiplicativeGenBytes)
	pkDomainFrMultiplicativeGenInvBytes := make([]byte, 32)
	r.Read(pkDomainFrMultiplicativeGenInvBytes)
	pk.Domain.FrMultiplicativeGenInv = byte_to_frElement(pkDomainFrMultiplicativeGenInvBytes)

	//Twiddles
	fmt.Println("Reading Twiddles")
	pk.Domain.Twiddles = readFrElementArrayDim2(r, false, "twiddle.bin")
	fmt.Println("Reading TwiddlesInv")
	pk.Domain.TwiddlesInv = readFrElementArrayDim2(r, false, "twiddleinv.bin")
	fmt.Println("Reading CosetTable")

	//pk.Domain.CosetTable = readFrElementArray(r, true, "cosettable.bin")
	pk.Domain.CosetTable = readFrElementArray(r, false, "cosettable.bin")
	fmt.Println("Reading CosetTableReversed")

	pk.Domain.CosetTableReversed = readFrElementArray(r, false, "cosettablereversed.bin")
	fmt.Println("Reading CosetTableInv")
	pk.Domain.CosetTableInv = readFrElementArray(r, false, "cosettableinv.bin")
	fmt.Println("Reading CosetTableInvReversed")
	pk.Domain.CosetTableInvReversed = readFrElementArray(r, false, "cosettableinvreversed.bin")

	//G1
	pkG1AlphaBytes := make([]byte, 64)
	r.Read(pkG1AlphaBytes)
	pk.G1.Alpha = byte_to_G1Affine(pkG1AlphaBytes)
	pkG1BetaBytes := make([]byte, 64)
	r.Read(pkG1BetaBytes)
	pk.G1.Beta = byte_to_G1Affine(pkG1BetaBytes)
	pkG1DeltaBytes := make([]byte, 64)
	r.Read(pkG1DeltaBytes)
	pk.G1.Delta = byte_to_G1Affine(pkG1DeltaBytes)

	fmt.Println("Reading G1A")
	pk.G1.A = readG1AffineArray(r, false, "g1a.bin")
	fmt.Println("Reading G1B")
	pk.G1.B = readG1AffineArray(r, false, "g1b.bin")
	fmt.Println("Reading G1Z")
	pk.G1.Z = readG1AffineArray(r, false, "g1z.bin")
	fmt.Println("Reading G1K")
	pk.G1.K = readG1AffineArray(r, false, "g1k.bin")

	//g2
	pkG2BetaBytes := make([]byte, 128)
	r.Read(pkG2BetaBytes)
	pk.G2.Beta = byte_to_G2Affine(pkG2BetaBytes)
	pkG2DeltaBytes := make([]byte, 128)
	r.Read(pkG2DeltaBytes)
	pk.G2.Delta = byte_to_G2Affine(pkG2DeltaBytes)
	fmt.Println("Reading G2B")
	pk.G2.B = readG2AffineArray(r, false, "g2b.bin")

	//nbWires
	var nbWires uint64
	pkNbWiresBytes := make([]byte, 8)
	r.Read(pkNbWiresBytes)
	nbWires = byte_to_uint64(pkNbWiresBytes)
	//nbInfinityA
	pkNbInfinityABytes := make([]byte, 8)
	r.Read(pkNbInfinityABytes)
	pk.NbInfinityA = byte_to_uint64(pkNbInfinityABytes)
	//nbInfinityB
	pkNbInfinityBBytes := make([]byte, 8)
	r.Read(pkNbInfinityBBytes)
	pk.NbInfinityB = byte_to_uint64(pkNbInfinityBBytes)

	//infinityA
	pk.InfinityA = make([]bool, nbWires)
	pk.InfinityB = make([]bool, nbWires)

	pk.InfinityA = ReadBoolArray(r)
	pk.InfinityB = ReadBoolArray(r)

	if len(pk.InfinityA) != int(nbWires) {
		panic("pk.InfinityA length is not equal to nbWires")
	}
	if len(pk.InfinityB) != int(nbWires) {
		panic("pk.InfinityB length is not equal to nbWires")
	}

	return 0, nil
}



func readG2AffineArrayParallel(buf []byte, offset *int, maxConcurrency int) []curve.G2Affine {
	fmt.Println("readG2AffineArray")
	t0 := time.Now()
	var result []curve.G2Affine
	length := byte_to_int(buf[*offset : *offset+8])
	*offset += 8
	result = make([]curve.G2Affine, length)
	if length < maxConcurrency * 16 {
		for i := 0; i < length; i++ {
			result[i] = byte_to_G2Affine(buf[*offset : *offset+128])
			*offset += 128
		}
	} else {
		channel := make(chan bool, maxConcurrency)
		chunkSize := length / maxConcurrency
		for i := 0; i < maxConcurrency; i++ {
			startIdxOffset := *offset + chunkSize * i
			endIdxOffset := *offset + chunkSize * (i + 1)
			if i == maxConcurrency - 1 {
				endIdxOffset = *offset + length
			}
			go func(startIdxOffset int, endIdxOffset int) {
				ByteOffset := startIdxOffset * 128
				for i := startIdxOffset; i < endIdxOffset; i++ {
					result[i] = byte_to_G2Affine(buf[ByteOffset : ByteOffset+128])
					ByteOffset += 128
				}
				channel <- true
			}(startIdxOffset, endIdxOffset)
		}
		for i := 0; i < maxConcurrency; i++ {
			<-channel
		}
		*offset += length * 128
	}
	fmt.Println("readG2AffineArray time:", time.Since(t0))
	return result
}

func readFrElementArrayParallel(buf []byte, offset *int, maxConcurrency int) []fr.Element {
	var result []fr.Element
	length := byte_to_int(buf[*offset : *offset+8])
	result = make([]fr.Element, length)

	if length < maxConcurrency * 128 {
		for i := 0; i < length; i++ {
			result[i] = byte_to_frElement(buf[*offset : *offset+32])
			*offset += 32
		}
	} else {
		channel := make(chan bool, maxConcurrency)
		chunkSize := length / maxConcurrency
		for i := 0; i < maxConcurrency; i++ {
			startIdxOffset := *offset + chunkSize * i
			endIdxOffset := *offset + chunkSize * (i + 1)
			if i == maxConcurrency - 1 {
				endIdxOffset = *offset + length
			}
			go func(startIdxOffset int, endIdxOffset int) {
				ByteOffset := startIdxOffset * 32
				for i := startIdxOffset; i < endIdxOffset; i++ {
					result[i] = byte_to_frElement(buf[ByteOffset : ByteOffset+32])
					ByteOffset += 32
				}
				channel <- true
			}(startIdxOffset, endIdxOffset)
		}
		for i := 0; i < maxConcurrency; i++ {
			<-channel
		}
		*offset += length * 32
	}
	return result
}

func readFrElementArrayDim2Parallel(buf []byte, offset *int, maxConcurrency int) [][]fr.Element {
	fmt.Println("Reading FrElementArrayDim2")
	t0 := time.Now()
	var result [][]fr.Element

	
	length := byte_to_int(buf[*offset : *offset+8])
	*offset += 8
	for i := 0; i < length; i++ {
		result = append(result, readFrElementArrayParallel(buf, offset, maxConcurrency))
	}
	
	t1 := time.Now()
	fmt.Println("Reading FrElementArrayDim2 took", t1.Sub(t0))
	return result
}


func readG1AffineArrayParallel(buf []byte, offset *int, maxConcurrency int) []curve.G1Affine {
	fmt.Println("readG1AffineArray")
	t0 := time.Now()
	var result []curve.G1Affine
	
	length := byte_to_int(buf[*offset : *offset+8])
	*offset += 8
	result = make([]curve.G1Affine, length)
	if length < maxConcurrency * 64 {
		for i := 0; i < length; i++ {
			result[i] = byte_to_G1Affine(buf[*offset : *offset+64])
			*offset += 64
		}
	} else {
		channel := make(chan bool, maxConcurrency)
		chunkSize := length / maxConcurrency
		for i := 0; i < maxConcurrency; i++ {
			startIdxOffset := *offset + chunkSize * i
			endIdxOffset := *offset + chunkSize * (i + 1)
			if i == maxConcurrency - 1 {
				endIdxOffset = *offset + length
			}
			go func(startIdxOffset int, endIdxOffset int) {
				ByteOffset := startIdxOffset * 64
				for i := startIdxOffset; i < endIdxOffset; i++ {
					result[i] = byte_to_G1Affine(buf[ByteOffset : ByteOffset+64])
					ByteOffset += 64
				}
				channel <- true
			}(startIdxOffset, endIdxOffset)
		}
		for i := 0; i < maxConcurrency; i++ {
			<-channel
		}
		*offset += length * 64
	}
	
	
	fmt.Println("readG1AffineArray time:", time.Since(t0))
	return result
}


func ReadBoolArrayParallel(buf []byte, offset *int, maxConcurrency int) []bool {
	var result []bool
	length := byte_to_int(buf[*offset : *offset+8])
	*offset += 8
	b := buf[*offset : *offset+length]
	*offset += length
	for i := 0; i < length; i++ {
		if b[i] == 1 {
			result = append(result, true)
		} else {
			result = append(result, false)
		}
	}
	return result
}

func (pk *ProvingKey) readFromBytes(buf []byte, maxConcurrency int) (int64, error) {

	fmt.Println("Reading from Bytes proving key")
	pkDomainCardinalityBytes := buf[0 : 8]
	pk.Domain.Cardinality = byte_to_uint64(pkDomainCardinalityBytes)
	pkDomainCardinalityInvBytes := buf[8 : 40]
	pk.Domain.CardinalityInv = byte_to_frElement(pkDomainCardinalityInvBytes)
	pkDomainGeneratorBytes := buf[40 : 72]
	pk.Domain.Generator = byte_to_frElement(pkDomainGeneratorBytes)
	pkDomainGeneratorInvBytes := buf[72 : 104]
	pk.Domain.GeneratorInv = byte_to_frElement(pkDomainGeneratorInvBytes)
	pkDomainFrMultiplicativeGenBytes := buf[104 : 136]
	pk.Domain.FrMultiplicativeGen = byte_to_frElement(pkDomainFrMultiplicativeGenBytes)
	pkDomainFrMultiplicativeGenInvBytes := buf[136 : 168]
	pk.Domain.FrMultiplicativeGenInv = byte_to_frElement(pkDomainFrMultiplicativeGenInvBytes)

	offset := 168
	//Twiddles
	fmt.Println("Reading Twiddles")
	pk.Domain.Twiddles = readFrElementArrayDim2Parallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading TwiddlesInv")
	pk.Domain.TwiddlesInv = readFrElementArrayDim2Parallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading CosetTable")

	//pk.Domain.CosetTable = readFrElementArray(r, true, "cosettable.bin")
	pk.Domain.CosetTable = readFrElementArrayParallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading CosetTableReversed")

	pk.Domain.CosetTableReversed = readFrElementArrayParallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading CosetTableInv")
	pk.Domain.CosetTableInv = readFrElementArrayParallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading CosetTableInvReversed")
	pk.Domain.CosetTableInvReversed = readFrElementArrayParallel(buf, &offset, maxConcurrency)

	//G1
	pk.G1.Alpha = byte_to_G1Affine(buf[offset : offset+64])
	pk.G1.Beta = byte_to_G1Affine(buf[offset+64 : offset+128])
	pk.G1.Delta = byte_to_G1Affine(buf[offset+128 : offset+192])
	offset += 192

	fmt.Println("Reading G1A")
	pk.G1.A = readG1AffineArrayParallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading G1B")
	pk.G1.B = readG1AffineArrayParallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading G1Z")
	pk.G1.Z = readG1AffineArrayParallel(buf, &offset, maxConcurrency)
	fmt.Println("Reading G1K")
	pk.G1.K = readG1AffineArrayParallel(buf, &offset, maxConcurrency)

	//g2
	pk.G2.Beta = byte_to_G2Affine(buf[offset : offset+128])
	pk.G2.Delta = byte_to_G2Affine(buf[offset+128 : offset+256])
	offset += 256

	fmt.Println("Reading G2B")
	pk.G2.B = readG2AffineArrayParallel(buf, &offset, maxConcurrency)

	//nbWires
	var nbWires uint64
	nbWires = byte_to_uint64(buf[offset : offset+8])
	//nbInfinityA
	pk.NbInfinityA = byte_to_uint64(buf[offset+8 : offset+16])
	//nbInfinityB
	pk.NbInfinityB = byte_to_uint64(buf[offset+16 : offset+24])
	offset += 24

	//infinityA
	pk.InfinityA = make([]bool, nbWires)
	pk.InfinityB = make([]bool, nbWires)

	pk.InfinityA = ReadBoolArrayParallel(buf, &offset, maxConcurrency)
	pk.InfinityB = ReadBoolArrayParallel(buf, &offset, maxConcurrency)

	if len(pk.InfinityA) != int(nbWires) {
		panic("pk.InfinityA length is not equal to nbWires")
	}
	if len(pk.InfinityB) != int(nbWires) {
		panic("pk.InfinityB length is not equal to nbWires")
	}

	return 0, nil
}
